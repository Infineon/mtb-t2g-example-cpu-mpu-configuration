/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cyhal.h"
#include "cybsp.h"
#include "cy_retarget_io.h"
#include "cy_prot.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define REGION_0_ADDR       (0x00000000ul) /* Back Ground Region Start Address */
#define REGION_1_ADDR       (0x10000000ul) /* Region 1 Start Address */
#define REGION_2_ADDR       (0x14000000ul) /* Region 2 Start Address */
#define REGION_3_ADDR       (0x28000000ul) /* Region 3 Start Address */
#define REGION_4_ADDR       (0x40000000ul) /* Region 4 Start Address */
#define REGION_5_ADDR       (0xE0000000ul) /* Region 5 Start Address */

#define TEST_1_ADDR         (0x10000000ul) /* Access Test 1 Target Address */
#define TEST_2_ADDR         (0x280C0000ul) /* Access Test 2 Target Address */
#define TEST_3_ADDR         (0x28100000ul) /* Access Test 3 Target Address */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/* setting up all of the memory region definitions */
const cy_stc_mpu_cfg_t MPU_CFG[] =
{
    /* Region 0 */
    {
        .address = (uint32_t *)REGION_0_ADDR,
        .privPermission = CY_PROT_PERM_DISABLED,
        .regionSize = CY_PROT_SIZE_4GB,
        .userPermission = CY_PROT_PERM_X
    },
    /* Region 1 */
    {
        .address = (uint32_t *)REGION_1_ADDR,
        .privPermission = CY_PROT_PERM_R,
        .regionSize = CY_PROT_SIZE_8MB,
        .userPermission = CY_PROT_PERM_RX
    },
    /* Region 2 */
    {
        .address = (uint32_t *)REGION_2_ADDR,
        .privPermission = CY_PROT_PERM_R,
        .regionSize = CY_PROT_SIZE_256KB,
        .userPermission = CY_PROT_PERM_DISABLED
    },
    /* Region 3 */
    {
        .address = (uint32_t *)REGION_3_ADDR,
        .privPermission = CY_PROT_PERM_RW,
        .regionSize = CY_PROT_SIZE_1MB,
        .userPermission = CY_PROT_PERM_RWX
    },
    /* Region 4 */
    {
        .address = (uint32_t *)REGION_4_ADDR,
        .privPermission = CY_PROT_PERM_RW,
        .regionSize = CY_PROT_SIZE_64MB,
        .userPermission = CY_PROT_PERM_RW
    },
    /* Region 5 */
    {
        .address = (uint32_t *)REGION_5_ADDR,
        .privPermission = CY_PROT_PERM_RW,
        .regionSize = CY_PROT_SIZE_512MB,
        .userPermission = CY_PROT_PERM_RW
    }
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/**********************************************************************************************************************
 * Function Name: Cy_SysLib_ProcessingFault
 * Summary:
 *  This function overrides the default fault processing handler to enable outputting of the MMFAR and the MMFSR on
 *  exception.
 * Parameters:
 *  none
 * Retrun:
 *  none
 **********************************************************************************************************************
 */
void Cy_SysLib_ProcessingFault(void)
{
    printf("Exception occurred, reset required to recover!\r\n");
    printf("MMFAR: %lu\r\n", cy_faultFrame.mmfar);
    printf("MMFSR: %lu\r\n", cy_faultFrame.cfsr.cfsrReg);

    #if defined(__ARMCC_VERSION)
        /* Assembly implementation of an infinite loop
         * is used for the armcc compiler to preserve the call stack.
         * Otherwise, the compiler destroys the call stack,
         * because treats this API as a no return function.
         */
        Cy_SysLib_AsmInfiniteLoop();
    #else
        while(true) {}
    #endif  /* (__ARMCC_VERSION) */
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function.
 * Parameters:
 *  none
 * Retrun:
 *  none
 **********************************************************************************************************************
 */
int main(void)
{
    uint8_t                     uartReadValue;              /* Variable for storing character read from terminal */
    uint32_t                    addrReadValue;              /* Variable for storing character read from memory */
    PROT_MPU_MPU_STRUCT_Type    mpuStruct;                  /* Variable to store the memory protection struct */
//    cy_rslt_t                   result;

#if defined (CY_DEVICE_SECURE)
    cyhal_wdt_t wdt_obj;

    /* Clear watchdog timer so that it doesn't trigger a reset */
    CY_ASSERT(cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms()) == CY_RSLT_SUCCESS);
    cyhal_wdt_free(&wdt_obj);
#endif

    /* Initialize the device and board peripherals */
    CY_ASSERT(cybsp_init() == CY_RSLT_SUCCESS);

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io to use the debug UART port */
    CY_ASSERT(cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE) == CY_RSLT_SUCCESS);

    /* Setup the MPU */
    CY_ASSERT(Cy_Prot_ConfigMpuStruct(&mpuStruct, MPU_CFG) == CY_PROT_SUCCESS);

    /* Enable the MPU */
    CY_ASSERT(Cy_Prot_EnableMpuStruct(&mpuStruct) == CY_PROT_SUCCESS);

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");

    printf("****************** "
           "Memory protection using the MPU"
           "****************** \r\n\n");
    printf("1: Read from 0x%08x, 2: Read from 0x%08x, 3: Read from 0x%08x\r\n", (unsigned int)TEST_1_ADDR, (unsigned int)TEST_2_ADDR, (unsigned int)TEST_3_ADDR);
    printf("Press 1 or 2 to display the data to be read. Pressing 3 will generate an exception.\r\n\n");

    for (;;)
    {
        /* Check if '1' key, '2' key or '3' key was pressed */
        if (cyhal_uart_getc(&cy_retarget_io_uart_obj, &uartReadValue, 1) == CY_RSLT_SUCCESS)
        {
            if (uartReadValue == '1')
            {
                /* read from TEST_1_ADDR */
                addrReadValue = *(volatile uint32_t*)(TEST_1_ADDR);
                printf("Read from 0x%08x returned: %lu\r\n\n", (unsigned int)TEST_1_ADDR, addrReadValue);
            }
            if (uartReadValue == '2')
            {
                /* read from TEST_2_ADDR */
                addrReadValue = *(volatile uint32_t*)(TEST_2_ADDR);
                printf("Read from 0x%08x returned: %lu\r\n\n", (unsigned int)TEST_2_ADDR, addrReadValue);
            }
            if (uartReadValue == '3')
            {
                /* read from TEST_3_ADDR */
                addrReadValue = *(volatile uint32_t*)(TEST_3_ADDR);
                printf("Read from 0x%08x returned: %lu\r\n\n", (unsigned int)TEST_3_ADDR, addrReadValue);
            }
        }
    }
}

/* [] END OF FILE */
